"""
cppyy Runtime Code Object
=========================
This is the core of our implementation. It handles:
1. Taking generated C++ code
2. Compiling it with cppyy
3. Executing it with numpy arrays
"""

import cppyy
import numpy as np

from brian2.codegen.codeobject import check_compiler_kwds, constant_or_scalar
from brian2.codegen.generators.cpp_generator import c_data_type
from brian2.codegen.generators.cppyy_generator import CppyyCodeGenerator
from brian2.codegen.runtime.numpy_rt import NumpyCodeObject
from brian2.codegen.targets import codegen_targets
from brian2.codegen.templates import Templater
from brian2.core.base import BrianObjectException
from brian2.core.functions import Function
from brian2.core.preferences import BrianPreference, prefs
from brian2.core.variables import (
    ArrayVariable,
    AuxiliaryVariable,
    DynamicArrayVariable,
    Subexpression,
)
from brian2.utils.logger import get_logger
from brian2.utils.stringtools import get_identifiers

logger = get_logger(__name__)

# Configure cppyy for better performance
# WHY: These settings optimize cppyy for numerical computing
cppyy.add_include_path(np.get_include())  # Include numpy headers

# Register preferences
prefs.register_preferences(
    "codegen.runtime.cppyy",
    "cppyy runtime codegen preferences",
    cache_compiled_functions=BrianPreference(
        default=True,
        docs="""
        Whether to cache JIT compiled functions. This avoids recompilation
        but uses more memory.
        """,
    ),
    debug_mode=BrianPreference(
        default=False,
        docs="""
        Whether to print generated C++ code before compilation for debugging.
        """,
    ),
)

# Global flag to track if support code has been compiled
_support_code_compiled = False


def compile_support_code():
    """Compile common support code once for all cppyy code objects."""
    global _support_code_compiled
    if _support_code_compiled:
        return

    support_code = """
    #include <cmath>
    #include <algorithm>
    #include <cstdint>
    #include <random>

    // Brian2 type definitions
    typedef int32_t int32;
    typedef int64_t int64;
    typedef float float32;
    typedef double float64;

    // Random number generation
    namespace brian {
        thread_local std::mt19937 _random_generator;

        inline double _rand(int idx) {
            std::uniform_real_distribution<double> dist(0.0, 1.0);
            return dist(_random_generator);
        }

        inline double _randn(int idx) {
            std::normal_distribution<double> dist(0.0, 1.0);
            return dist(_random_generator);
        }

        template<typename T>
        inline T _clip(T x, T low, T high) {
            return std::min(std::max(x, low), high);
        }

        inline int _int(double x) { return (int)x; }
        inline int _int(bool x) { return x ? 1 : 0; }

        template<typename T>
        inline T _brian_mod(T x, T y) {
            return x - y * floor(x/y);
        }
    }

    using namespace brian;
    """

    try:
        cppyy.cppdef(support_code)
        _support_code_compiled = True
        logger.debug("Compiled cppyy support code")
    except Exception as e:
        logger.error(f"Failed to compile support code: {e}")
        raise


class CppyyCodeObject(NumpyCodeObject):
    """
    Execute Brian2 code using cppyy JIT compilation.

    This class is responsible for:
    1. Taking the C++ code generated by CppyyCodeGenerator
    2. Compiling it using cppyy's JIT compiler
    3. Executing the compiled function with Brian2's data
    """

    # Tell Brian2 which templates and generator to use
    templater = Templater(
        "brian2.codegen.runtime.cppyy_rt",
        ".cpp",  # We use .cpp extension for our templates
        env_globals={
            "dtype": np.dtype,
            "c_data_type": c_data_type,
            "constant_or_scalar": constant_or_scalar,
            "prefs": prefs,
        },
    )

    generator_class = CppyyCodeGenerator
    class_name = "cppyy"

    def __init__(
        self,
        owner,
        code,
        variables,
        variable_indices,
        template_name,
        template_source,
        compiler_kwds,
        name="cppyy_code_object*",
    ):
        """
        Initialize a cppyy code object.

        Parameters:
        -----------
        owner : Group
            The NeuronGroup or Synapses object that owns this code
        code : str
            The generated C++ code
        variables : dict
            Dictionary of Variable objects used in the code
        variable_indices : dict
            Mapping of variables to their index arrays
        template_name : str
            Name of the template used (e.g., 'stateupdate')
        """
        logger.debug(f"Creating cppyy code object: {name}")
        # Check compiler keywords (we don't use many for cppyy)
        check_compiler_kwds(
            compiler_kwds,
            ["include_dirs", "libraries"],  # Minimal set for cppyy
            "cppyy",
        )
        super().__init__(
            owner,
            code,
            variables,
            variable_indices,
            template_name,
            template_source,
            compiler_kwds={},  # Don't pass compiler args to numpy
            name=name,
        )

        # Ensure support code is compiled
        compile_support_code()

        # Store compiled functions for each code block
        self.compiled_funcs = {}

        # Lists for tracking non-constant values (like CythonCodeObject)
        self.nonconstant_values = []

    @classmethod
    def is_available(cls):
        """Check if cppyy is available and working."""
        try:
            import cppyy

            cppyy.cppdef("void test_func() { }")
            cppyy.gbl.test_func()
            return True
        except ImportError:
            return False

    def compile_block(self, block):
        """
        Compile a specific code block (before_run, run, after_run).
        """
        # Get the code for this block first
        code = getattr(self.code, block, "").strip()
        if not code or "EMPTY_CODE_BLOCK" in code:
            return None

        # Generate unique function Name
        func_name = f"{self.name.replace('*' , '').replace('-' , '_')}_{block}"
        # Build complete C++ function
        cpp_code = self._build_block_function(func_name, code)

        if prefs["codegen.runtime.cppyy.debug_mode"]:
            logger.debug(f"Compiling {block} block:\n{cpp_code}")

        try:
            # Compile with cppyy
            cppyy.cppdef(cpp_code)

            # Get reference to compiled function
            compiled_func = getattr(cppyy.gbl, func_name)

            return compiled_func

        except Exception as e:
            logger.error(f"Failed to compile {block} block: {e}")
            if prefs["codegen.runtime.cppyy.debug_mode"]:
                logger.error(f"Code was:\n{cpp_code}")
            raise

    def _build_block_function(self, func_name, template_code):
        """
        Build a complete C++ function from template code.

        WHY: Templates generate code fragments, we need to wrap them
        in a proper C++ function that cppyy can compile.
        """
        # Extract array parameters from variables
        params = []
        param_setup = []

        for varname, var in self.variables.items():
            if isinstance(var, ArrayVariable):
                dtype = c_data_type(var.dtype)
                ptr_name = f"_ptr_{varname}"
                # Function parameter
                params.append(f"void* {ptr_name}_void")

                # Cast to proper type inside function
                param_setup.append(f"{dtype}* {ptr_name} = ({dtype}*){ptr_name}_void;")

                # Add size parameter for dynamic arrays
                if isinstance(var, DynamicArrayVariable):
                    params.append(f"int _num_{varname}")

        # Add standard parameters
        params.extend(["double t", "double dt", "int N"])

        # Build the function
        function_code = f"""
        extern "C" void {func_name}({', '.join(params)}) {{
            // Cast void pointers to proper types
            {' '.join(param_setup)}

            // Original template code
            {template_code}
        }}
        """

        return function_code

    def run_block(self, block):
        """
        Run a compiled code block.

        This is called by Brian2's execution system.
        """
        compiled_func = self.compiled_code.get(block)

        if compiled_func is None:
            return  # Nothing to run

        try:
            # Prepare arguments for the C++ function
            args = []

            # Add array pointers
            for _, var in self.variables.items():
                if isinstance(var, ArrayVariable):
                    # Get the numpy array
                    value = var.get_value()
                    if isinstance(value, np.ndarray):
                        # Pass the data pointer
                        args.append(value.ctypes.data)

                        # Add size for dynamic arrays
                        if isinstance(var, DynamicArrayVariable):
                            args.append(len(value))

            # Add scalar values
            args.append(self.namespace.get("t", 0.0))
            args.append(self.namespace.get("dt", 0.0001))
            args.append(self.namespace.get("N", 0))

            # Call the compiled function
            compiled_func(*args)

        except Exception as exc:
            message = (
                f"An exception occurred during execution of the "
                f"'{block}' block of code object '{self.name}'.\n"
            )
            raise BrianObjectException(message, self.owner) from exc

    def _insert_func_namespace(self, func):
        """Insert function namespace (copied from CythonCodeObject)."""
        impl = func.implementations[self]
        func_namespace = impl.get_namespace(self.owner)
        if func_namespace is not None:
            self.namespace.update(func_namespace)
        if impl.dependencies is not None:
            for dep in impl.dependencies.values():
                self._insert_func_namespace(dep)

    def variables_to_namespace(self):
        """
        Convert variables to namespace (adapted from CythonCodeObject).

        WHY: We need to make variables accessible to the compiled code
        and track which ones change during execution.
        """
        # Lists for tracking non-constant values
        self.nonconstant_values = []

        for name, var in self.variables.items():
            if isinstance(var, Function):
                self._insert_func_namespace(var)
            if isinstance(var, (AuxiliaryVariable, Subexpression)):
                continue

            try:
                value = var.get_value()
            except (TypeError, AttributeError):
                # A dummy Variable without value or a function
                self.namespace[name] = var
                continue

            if isinstance(var, ArrayVariable):
                # Store array reference
                array_name = self.device.get_array_name(var, self.variables)
                self.namespace[array_name] = value
                self.namespace[f"_num_{name}"] = var.get_len()

                if var.scalar and var.constant:
                    self.namespace[name] = value.item()
            else:
                self.namespace[name] = value

            # Handle dynamic arrays
            if isinstance(var, DynamicArrayVariable):
                dyn_array_name = self.generator_class.get_array_name(
                    var, access_data=False
                )
                self.namespace[dyn_array_name] = self.device.get_value(
                    var, access_data=False
                )

            # Store Variable object itself
            self.namespace[f"_var_{name}"] = var

        # Filter namespace to only include used identifiers
        all_identifiers = set()
        for block in ["before_run", "run", "after_run"]:
            if hasattr(self.code, block):
                code = getattr(self.code, block)
                all_identifiers.update(get_identifiers(code))

        self.namespace = {
            k: v
            for k, v in self.namespace.items()
            if k in all_identifiers or k.startswith("_")
        }

        # Track dynamic arrays that need updates
        for name, var in self.variables.items():
            if isinstance(var, DynamicArrayVariable) and var.needs_reference_update:
                array_name = self.device.get_array_name(var, self.variables)
                if array_name in self.namespace:
                    self.nonconstant_values.append((array_name, var.get_value))
                if f"_num_{name}" in self.namespace:
                    self.nonconstant_values.append((f"_num_{name}", var.get_len))

    def update_namespace(self):
        """Update the values of non-constant values in the namespace."""
        for name, func in self.nonconstant_values:
            self.namespace[name] = func()


codegen_targets.add(CppyyCodeObject)
